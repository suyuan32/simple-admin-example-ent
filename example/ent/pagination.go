// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-example-api/ent/course"
	"github.com/suyuan32/simple-admin-example-api/ent/exam"
	"github.com/suyuan32/simple-admin-example-api/ent/student"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type CoursePager struct {
	Order  course.OrderOption
	Filter func(*CourseQuery) (*CourseQuery, error)
}

// CoursePaginateOption enables pagination customization.
type CoursePaginateOption func(*CoursePager)

// DefaultCourseOrder is the default ordering of Course.
var DefaultCourseOrder = Desc(course.FieldID)

func newCoursePager(opts []CoursePaginateOption) (*CoursePager, error) {
	pager := &CoursePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultCourseOrder
	}
	return pager, nil
}

func (p *CoursePager) ApplyFilter(query *CourseQuery) (*CourseQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// CoursePageList is Course PageList result.
type CoursePageList struct {
	List        []*Course    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (c *CourseQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...CoursePaginateOption,
) (*CoursePageList, error) {

	pager, err := newCoursePager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.ApplyFilter(c); err != nil {
		return nil, err
	}

	ret := &CoursePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := c.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		c = c.Order(pager.Order)
	} else {
		c = c.Order(DefaultCourseOrder)
	}

	c = c.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ExamPager struct {
	Order  exam.OrderOption
	Filter func(*ExamQuery) (*ExamQuery, error)
}

// ExamPaginateOption enables pagination customization.
type ExamPaginateOption func(*ExamPager)

// DefaultExamOrder is the default ordering of Exam.
var DefaultExamOrder = Desc(exam.FieldID)

func newExamPager(opts []ExamPaginateOption) (*ExamPager, error) {
	pager := &ExamPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultExamOrder
	}
	return pager, nil
}

func (p *ExamPager) ApplyFilter(query *ExamQuery) (*ExamQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ExamPageList is Exam PageList result.
type ExamPageList struct {
	List        []*Exam      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (e *ExamQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ExamPaginateOption,
) (*ExamPageList, error) {

	pager, err := newExamPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.ApplyFilter(e); err != nil {
		return nil, err
	}

	ret := &ExamPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := e.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		e = e.Order(pager.Order)
	} else {
		e = e.Order(DefaultExamOrder)
	}

	e = e.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type StudentPager struct {
	Order  student.OrderOption
	Filter func(*StudentQuery) (*StudentQuery, error)
}

// StudentPaginateOption enables pagination customization.
type StudentPaginateOption func(*StudentPager)

// DefaultStudentOrder is the default ordering of Student.
var DefaultStudentOrder = Desc(student.FieldID)

func newStudentPager(opts []StudentPaginateOption) (*StudentPager, error) {
	pager := &StudentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultStudentOrder
	}
	return pager, nil
}

func (p *StudentPager) ApplyFilter(query *StudentQuery) (*StudentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// StudentPageList is Student PageList result.
type StudentPageList struct {
	List        []*Student   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *StudentQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...StudentPaginateOption,
) (*StudentPageList, error) {

	pager, err := newStudentPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.ApplyFilter(s); err != nil {
		return nil, err
	}

	ret := &StudentPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := s.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		s = s.Order(pager.Order)
	} else {
		s = s.Order(DefaultStudentOrder)
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
